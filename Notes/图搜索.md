# 图搜索

## 深度优先遍历

### [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

#### 方法一：深度优先搜索

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。

最终岛屿的数量就是我们进行深度优先搜索的次数。

```cpp
class Solution {
private:
    // DFS 函数：将当前岛屿的所有陆地单元格标记为已访问（'0'）
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();     // 行数
        int nc = grid[0].size();  // 列数
        
        // 将当前陆地标记为已访问（沉没为水）
        grid[r][c] = '0';
        
        // 递归访问四个方向的相邻单元格（上下左右）
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);  // 上
        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);  // 下
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);  // 左
        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);  // 右
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;           // 空网格
        int nc = grid[0].size();
        
        int num_islands = 0;
        // 遍历整个网格
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {     // 发现新岛屿
                    ++num_islands;           // 岛屿计数+1
                    dfs(grid, r, c);         // 沉没整个岛屿
                }
            }
        }
        
        return num_islands;
    }
};
```

#### 方法二：广度优先搜索

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;           // 空网格
        int nc = grid[0].size();
        
        int num_islands = 0;
        // 遍历整个网格
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {     // 发现新岛屿
                    ++num_islands;           // 岛屿计数+1
                    
                    grid[r][c] = '0';        // 标记当前单元格为已访问
                    queue<pair<int, int>> neighbors;  // BFS队列
                    neighbors.push({r, c});  // 将起始单元格加入队列
                    
                    // BFS遍历整个岛屿
                    while (!neighbors.empty()) {
                        auto rc = neighbors.front();
                        neighbors.pop();
                        int row = rc.first, col = rc.second;
                        
                        // 检查四个方向的相邻单元格
                        // 上
                        if (row - 1 >= 0 && grid[row-1][col] == '1') {
                            neighbors.push({row-1, col});
                            grid[row-1][col] = '0';  // 入队时立即标记，避免重复入队
                        }
                        // 下
                        if (row + 1 < nr && grid[row+1][col] == '1') {
                            neighbors.push({row+1, col});
                            grid[row+1][col] = '0';
                        }
                        // 左
                        if (col - 1 >= 0 && grid[row][col-1] == '1') {
                            neighbors.push({row, col-1});
                            grid[row][col-1] = '0';
                        }
                        // 右
                        if (col + 1 < nc && grid[row][col+1] == '1') {
                            neighbors.push({row, col+1});
                            grid[row][col+1] = '0';
                        }
                    }
                }
            }
        }
        
        return num_islands;
    }
};
```

#### 方法三：并查集

```cpp
// 并查集类
class UnionFind {
public:
    // 构造函数：初始化并查集
    UnionFind(vector<vector<char>>& grid) {
        count = 0;  // 初始岛屿数量（每个'1'都是一个独立岛屿）
        int m = grid.size();
        int n = grid[0].size();
        
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    parent.push_back(i * n + j);  // 每个陆地的父节点初始化为自己
                    ++count;  // 陆地计数
                } else {
                    parent.push_back(-1);  // 水域节点父节点为-1
                }
                rank.push_back(0);  // 初始化秩为0
            }
        }
    }

    // 查找：路径压缩
    int find(int i) {
        if (parent[i] != i) {
            parent[i] = find(parent[i]);  // 路径压缩
        }
        return parent[i];
    }

    // 合并：按秩合并
    void unite(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
            // 按秩合并：将秩小的树合并到秩大的树上
            if (rank[rootx] < rank[rooty]) {
                swap(rootx, rooty);
            }
            parent[rooty] = rootx;
            if (rank[rootx] == rank[rooty]) {
                rank[rootx] += 1;  // 秩相等时，合并后秩+1
            }
            --count;  // 合并后连通分量减少
        }
    }

    // 获取当前连通分量数量（岛屿数量）
    int getCount() const {
        return count;
    }

private:
    vector<int> parent;  // 父节点数组
    vector<int> rank;    // 秩数组（树的高度）
    int count;           // 连通分量数量
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();
        
        // 1. 初始化并查集
        UnionFind uf(grid);
        
        // 2. 遍历网格，合并相邻的陆地
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';  // 标记为已访问（可选，这里用于避免重复检查）
                    
                    // 检查四个方向的相邻单元格
                    int id = r * nc + c;  // 当前单元格的一维索引
                    // 上
                    if (r - 1 >= 0 && grid[r-1][c] == '1') {
                        uf.unite(id, (r-1) * nc + c);
                    }
                    // 下
                    if (r + 1 < nr && grid[r+1][c] == '1') {
                        uf.unite(id, (r+1) * nc + c);
                    }
                    // 左
                    if (c - 1 >= 0 && grid[r][c-1] == '1') {
                        uf.unite(id, r * nc + c - 1);
                    }
                    // 右
                    if (c + 1 < nc && grid[r][c+1] == '1') {
                        uf.unite(id, r * nc + c + 1);
                    }
                }
            }
        }
        
        // 3. 返回连通分量数量
        return uf.getCount();
    }
};
```

### [394. 字符串解码 - 力扣（LeetCode）](https://leetcode.cn/problems/decode-string/description/)

输入：`s = "3[a2[c]]"`
输出：`"accaccacc"`

[394. 字符串解码 - 力扣（LeetCode）](https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)

#### 解法一：辅助栈法

```cpp
class Solution {
public:
    string decodeString(string s) {
        string res = "";            // 当前层的字符串结果
        int multi = 0;              // 当前重复次数（用于解析数字）
        
        // 使用两个栈分别保存重复次数和上一层的结果
        stack<int> stack_multi;     // 保存重复次数
        stack<string> stack_res;    // 保存上一层已解析的字符串
        
        for (char c : s) {
            if (c == '[') {
                // 遇到 '['，将当前状态压栈，开启新的内层解析
                stack_multi.push(multi);   // 保存当前的重复次数
                stack_res.push(res);       // 保存当前已解析的字符串
                
                // 重置状态，准备解析内层字符串
                multi = 0;
                res = "";
            }
            else if (c == ']') {
                // 遇到 ']'，内层解析完成，进行字符串重复
                int cur_multi = stack_multi.top();
                stack_multi.pop();
                
                string last_res = stack_res.top();
                stack_res.pop();
                
                // 将当前内层字符串重复 cur_multi 次
                string temp = "";
                for (int i = 0; i < cur_multi; i++) {
                    temp += res;
                }
                
                // 将重复后的字符串拼接到上一层结果后面
                res = last_res + temp;
            }
            else if (c >= '0' && c <= '9') {
                // 解析数字（可能多位）
                multi = multi * 10 + (c - '0');
            }
            else {
                // 普通字符，直接添加到当前结果
                res += c;
            }
        }
        
        return res;
    }
};
```
#### 解法二：递归法

```cpp
class Solution {
public:
    string decodeString(string s) {
        int index = 0;  // 用于跟踪当前解析位置
        return dfs(s, index);
    }

private:
    // 递归解析函数：s: 输入字符串；i: 当前解析位置的引用（需要修改，所以用引用）
    // 返回值：解析出的字符串
    string dfs(const string& s, int& i) {
        string res = "";  // 当前层的解析结果
        int multi = 0;    // 当前重复次数
        
        while (i < s.length()) {
            char c = s[i];
            
            if (c >= '0' && c <= '9') {
                // 解析数字，支持多位数字
                multi = multi * 10 + (c - '0');
            }
            else if (c == '[') {
                // 遇到左括号，递归解析内层字符串
                i++;  // 跳过 '['
                string innerStr = dfs(s, i);  // 递归解析括号内的内容
                
                // 将内层字符串重复 multi 次
                for (int k = 0; k < multi; k++) {
                    res += innerStr;
                }
                multi = 0;  // 重置重复次数
            }
            else if (c == ']') {
                // 遇到右括号，返回当前层的结果
                // 注意：这里不递增 i，由外层调用处理 ']'
                return res;
            }
            else {
                // 普通字符，直接添加到结果
                res += c;
            }
            
            i++;  // 移动到下一个字符
        }
        
        // 解析完成，返回最终结果
        return res;
    }
};
```

### [199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

![[Pasted image 20251229135907.png]]

采用深度优先遍历，优先访问右子树，当某一层第一次被访问时，记录该结点值，即得到二叉树的右视图。
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {
            if (node == nullptr) {
                return; // 空结点直接返回
            }
            if (depth == ans.size()) { // 这个深度首次遇到
                ans.push_back(node->val);
            }
            dfs(node->right, depth + 1); // 先递归右子树，保证首次遇到的一定是最右边的节点
            dfs(node->left, depth + 1);
        };
        dfs(root, 0);
        return ans;
    }
};
```

### [207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

拓扑排序。

#### 方法一：深度优先搜索

我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有**已经搜索完成的节点**。

对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。

```cpp
class Solution {
private:
    vector<vector<int>> edges;  // 邻接表：edges[u] 表示 u 指向的所有课程
    vector<int> visited;        // 访问状态数组
                                 // 0：未访问
                                 // 1：正在访问（递归栈中）
                                 // 2：已访问完成
    bool valid = true;           // 是否存在环，true 表示目前仍然合法

public:
    // 对课程 u 进行 DFS
    void dfs(int u) {
        visited[u] = 1;          // 标记 u 为“正在访问”

        // 遍历 u 的所有后继课程 v
        for (int v : edges[u]) {
            if (visited[v] == 0) {     // v 未访问
                dfs(v);                // 继续 DFS
                if (!valid) {          // 如果子过程中发现了环
                    return;             // 立即返回
                }
            }
            else if (visited[v] == 1) { // v 正在访问中
                // 说明从 u → v，v 又在当前 DFS 路径中
                // 出现回边，说明图中有环
                valid = false;
                return;
            }
        }

        visited[u] = 2;          // u 的所有后继都访问完毕，标记为“已完成”
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);

        // 建图：bi → ai（学 ai 之前必须学 bi）
        for (const auto& info : prerequisites) {
            edges[info[1]].push_back(info[0]);
        }

        // 对每一门课做 DFS（防止图不连通）
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }

        return valid; // 没有环则可以完成所有课程
    }
};
```

#### ⭐方法二: 广度优先搜索

我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点**少了一门先修课程的要求**。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。

```cpp
class Solution {
private:
    vector<vector<int>> edges; // 邻接表：edges[u] 表示 u 的后继课程
    vector<int> indeg;         // 入度数组：indeg[i] 表示课程 i 的先修数量

public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);

        // 建图并统计入度
        for (const auto& info : prerequisites) {
            edges[info[1]].push_back(info[0]); // bi → ai
            ++indeg[info[0]];                  // ai 的入度 +1
        }

        queue<int> q;

        // 将所有入度为 0 的课程加入队列
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }

        int visited = 0; // 已“学完”的课程数量

        // BFS 拟拓扑排序过程
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            ++visited;  // 成功学完一门课

            // 遍历 u 的所有后继课程
            for (int v : edges[u]) {
                --indeg[v];        // 删除 u → v 这条边
                if (indeg[v] == 0) {
                    q.push(v);     // v 可以学习了
                }
            }
        }

        // 如果能学完所有课程，说明无环
        return visited == numCourses;
    }
};
```

### [114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

- 展开后的单链表应该与二叉树**先序遍历**顺序相同。

![[Pasted image 20251229153827.png]]

#### 方法一：前序遍历

[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        vector<TreeNode*> l;
        preorderTraversal(root, l);
        int n = l.size();
        for (int i = 1; i < n; i++) {
            TreeNode *prev = l.at(i - 1), *curr = l.at(i);
            prev->left = nullptr;
            prev->right = curr;
        }
    }

    void preorderTraversal(TreeNode* root, vector<TreeNode*> &l) {
        if (root != NULL) {
            l.push_back(root);
            preorderTraversal(root->left, l);
            preorderTraversal(root->right, l);
        }
    }
};
```

#### 方法二：前序遍历和展开同步进行

只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        if (root == nullptr) return;
        
        stack<TreeNode*> stk;
        stk.push(root);
        TreeNode* prev = nullptr;  // 前一个访问的节点
        
        while (!stk.empty()) {
            TreeNode* curr = stk.top();
            stk.pop();
            
            // 将前一个节点的right指向当前节点，left置空
            if (prev != nullptr) {
                prev->left = nullptr;
                prev->right = curr;
            }
            
            // 先右后左入栈，保证出栈顺序是先序（根→左→右）
            if (curr->right != nullptr) {
                stk.push(curr->right);
            }
            if (curr->left != nullptr) {
                stk.push(curr->left);
            }
            
            prev = curr;  // 更新前一个节点
        }
    }
};
```

#### ⭐方法三：Morris遍历变种

1. 将左子树插入到右子树的地方
2. 将原来的右子树接到左子树的最右边节点
3. 考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;  // 当前处理节点
        
        while (curr != nullptr) {
            // 情况1：左子树为空，直接处理右子树
            if (curr->left == nullptr) {
                curr = curr->right;  // 移动到右子节点
            } 
            // 情况2：左子树不为空，需要重组结构
            else {
                // 找到左子树中最右边的节点（前驱节点）
                TreeNode* pre = curr->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                
                // 将当前节点的右子树接到前驱节点的右边
                pre->right = curr->right;
                
                // 将左子树移到右边，左指针置空
                curr->right = curr->left;
                curr->left = nullptr;
                
                // 继续处理下一个节点（原来的左子树，现在的右子树）
                curr = curr->right;
            }
        }
    }
};
```

### [863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/)

返回到目标结点 `target` 距离为 `k` 的所有结点的值的数组。

#### 方法：将树转化为图 + DFS

通过记录父节点，让二叉树变成**无向图**，每个节点有三个邻居：左孩子、右孩子、父节点。
```cpp
class Solution {
    unordered_map<int, TreeNode*> parents;  // 节点值 → 父节点指针（值唯一）
    vector<int> ans;  // 存储距离为K的节点值

    // 建立父子关系映射（DFS遍历）
    void findParents(TreeNode* node) {
        if (node->left != nullptr) {
            parents[node->left->val] = node;  // 记录左孩子的父节点
            findParents(node->left);
        }
        if (node->right != nullptr) {
            parents[node->right->val] = node;  // 记录右孩子的父节点
            findParents(node->right);
        }
    }

    // 从目标节点出发，寻找距离为K的所有节点（DFS）
    // node: 当前节点
    // from: 来源节点（避免走回头路）
    // depth: 当前深度（距离target的步数）
    // k: 目标距离
    void findAns(TreeNode* node, TreeNode* from, int depth, int k) {
        if (node == nullptr) {
            return;
        }
        if (depth == k) {  // 找到距离为K的节点
            ans.push_back(node->val);
            return;
        }
        
        // 向三个方向搜索（左、右、父），但要避免走回头路
        if (node->left != from) {
            findAns(node->left, node, depth + 1, k);
        }
        if (node->right != from) {
            findAns(node->right, node, depth + 1, k);
        }
        if (parents[node->val] != from) {  // 检查父节点方向
            findAns(parents[node->val], node, depth + 1, k);
        }
    }

public:
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        // 步骤1：建立所有节点的父节点映射
        // 注意：root的父节点不会被记录（值为空），但findAns中会检查
        findParents(root);

        // 步骤2：从target出发，DFS搜索距离为K的所有节点
        findAns(target, nullptr, 0, k);

        return ans;
    }
};
```

### [131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/description/)

输入：`s = "aab"`
输出：`["a","a","b"],["aa","b"]]`

#### 方法一：输入的视角（逗号选或不选）

是否要在 i 和 i+1 处分割，把 s[i] 作为当前子串的最后一个字符，把 s[i+1] 作为下一个子串的第一个字符。
注意 s[n−1] 一定是最后一个字符，所以在 i=n−1 的时候一定要分割。

如果最后一个字符串不是回文串，我们不会递归到 i=n 的边界，不会把不合法的分割加入答案。

```cpp
class Solution {
    bool is_palindrome(const string& s, int left, int right) {
        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }

public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<string>> ans;
        vector<string> path;

        // 考虑 i 后面的逗号怎么选
        // start 表示当前这段回文子串的开始位置
        auto dfs = [&](this auto&& dfs, int i, int start) { // `auto&&` 是转发引用/通用引用
            if (i == n) { // s 分割完毕
                ans.emplace_back(path);
                return;
            }

            // 不分割，不选 i 和 i+1 之间的逗号
            if (i < n - 1) { // i=n-1 时只能分割
                // 考虑 i+1 后面的逗号怎么选
                dfs(i + 1, start);
            }

            // 分割，选 i 和 i+1 之间的逗号（把 s[i] 作为子串的最后一个字符）
            if (is_palindrome(s, start, i)) {
                path.emplace_back(s.substr(start, i - start + 1));
                // 考虑 i+1 后面的逗号怎么选
                // start=i+1 表示下一个子串从 i+1 开始
                dfs(i + 1, i + 1);
                path.pop_back(); // 恢复现场
            }
        };

        dfs(0, 0);
        return ans;
    }
};
```
#### 方法二：答案的视角（枚举子串结束位置）

```cpp
class Solution {
    bool isPalindrome(const string& s, int left, int right) {
        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }

public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<string>> ans;
        vector<string> path;

        // 考虑 s[i] ~ s[n-1] 怎么分割
        auto dfs = [&](this auto&& dfs, int i) {
            if (i == n) { // s 分割完毕
                ans.emplace_back(path);
                return;
            }
            for (int j = i; j < n; j++) { // 枚举子串的结束位置
                if (isPalindrome(s, i, j)) {
                    path.push_back(s.substr(i, j - i + 1)); // 分割！
                    // 考虑剩余的 s[j+1] ~ s[n-1] 怎么分割
                    dfs(j + 1);
                    path.pop_back(); // 恢复现场
                }
            }
        };

        dfs(0);
        return ans;
    }
};
```

### [547. 省份数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-provinces/description/)

计算连通分量数的一个方法是使用并查集。

## 广度优先遍历

### [103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)

先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。

输入：`root = [3,9,20,null,null,15,7]`
输出：`[[3],[20,9],[15,7]]`

#### 方法一：层序遍历 + 双端队列

此题是「[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)」的变种，最后输出的要求有所变化，要求我们按层数的奇偶来决定每一层的输出顺序。
为了满足题目要求的**返回值**为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;  // 存储最终结果
        if (!root) {
            return ans;  // 空树直接返回
        }

        queue<TreeNode*> nodeQueue;  // BFS队列
        nodeQueue.push(root);
        bool isOrderLeft = true;  // 控制方向：true表示从左到右，false表示从右到左

        while (!nodeQueue.empty()) {
            deque<int> levelList;  // 双端队列存储当前层的结果
            int size = nodeQueue.size();  // 当前层的节点数
            
            // 遍历当前层所有节点
            for (int i = 0; i < size; ++i) {
                auto node = nodeQueue.front();
                nodeQueue.pop();
                
                // 根据方向决定插入位置
                if (isOrderLeft) {
                    levelList.push_back(node->val);  // 从左到右：插入队尾
                } else {
                    levelList.push_front(node->val); // 从右到左：插入队头
                }
                
                // 将子节点加入队列（先左后右）
                if (node->left) {
                    nodeQueue.push(node->left);
                }
                if (node->right) {
                    nodeQueue.push(node->right);
                }
            }
            
            // 将当前层结果转换为vector并添加到答案中
            ans.emplace_back(vector<int>{levelList.begin(), levelList.end()});
            
            // 切换方向
            isOrderLeft = !isOrderLeft;
        }

        return ans;
    }
};
```
#### 方法二：层序遍历 + 倒序

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        queue<TreeNode*> que;          // BFS队列
        vector<vector<int>> res;       // 最终结果
        
        if (root != NULL) {
            que.push(root);            // 根节点入队
        }
        
        while (!que.empty()) {
            vector<int> tmp;           // 存储当前层的节点值
            
            // 遍历当前层的所有节点
            for(int i = que.size(); i > 0; i--) {
                TreeNode* node = que.front();
                que.pop();
                tmp.push_back(node->val);  // 按从左到右顺序收集
                
                // 将子节点加入队列（先左后右）
                if (node->left != NULL) {
                    que.push(node->left);
                }
                if (node->right != NULL) {
                    que.push(node->right);
                }
            }
            
            // 所以偶数层（从0开始）实际是第1、3、5...层（从左到右）
            // 奇数层（从0开始）实际是第2、4、6...层（从右到左，需要反转）
            if (res.size() % 2 == 1) {
                reverse(tmp.begin(), tmp.end());  // 反转当前层结果
            }
            
            res.push_back(tmp);  // 将当前层加入结果
        }
        
        return res;
    }
};
```
### [994. 腐烂的橘子 - 力扣（LeetCode）](https://leetcode.cn/problems/rotting-oranges/description/)

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 _直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`_ 。

![[Pasted image 20251229183845.png]]

输入：`grid = [[2,1,1],[1,1,0],[0,1,1]]`
输出：`4`

实际上就是求**腐烂橘子到所有新鲜橘子的最短路径**，使用 BFS！
在每一层遍历开始前，记录队列中的结点数量 n ，然后一口气处理完这一层的 n 个结点。

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int M = grid.size();      // 网格行数
        int N = grid[0].size();   // 网格列数
        queue<pair<int, int>> que; // BFS队列，存储腐烂橘子的坐标
        
        int count = 0;  // 新鲜橘子的数量
        // 第一遍遍历：统计新鲜橘子，将腐烂橘子加入队列
        for (int r = 0; r < M; r++) {
            for (int c = 0; c < N; c++) {
                if (grid[r][c] == 1) {
                    count++;            // 新鲜橘子计数
                } else if (grid[r][c] == 2) {
                    que.push({r, c});   // 腐烂橘子入队，作为BFS起点
                }
            }
        }
        
        int minutes = 0;  // 腐烂所需时间（轮数）
        
        // BFS遍历，直到所有新鲜橘子腐烂或无法继续腐烂
        while (count > 0 && !que.empty()) {
            minutes++;  // 新一轮腐烂开始
            
            int levelSize = que.size();  // 当前层（当前分钟）的腐烂橘子数量
            for (int i = 0; i < levelSize; i++) {
                auto [r, c] = que.front();  // 取出一个腐烂橘子
                que.pop();
                
                // 检查并腐烂四个方向相邻的新鲜橘子
                // 上
                if (r - 1 >= 0 && grid[r-1][c] == 1) {
                    grid[r-1][c] = 2;      // 标记为腐烂
                    count--;               // 新鲜橘子减少
                    que.push({r-1, c});    // 新腐烂橘子入队
                }
                // 下
                if (r + 1 < M && grid[r+1][c] == 1) {
                    grid[r+1][c] = 2;
                    count--;
                    que.push({r+1, c});
                }
                // 左
                if (c - 1 >= 0 && grid[r][c-1] == 1) {
                    grid[r][c-1] = 2;
                    count--;
                    que.push({r, c-1});
                }
                // 右
                if (c + 1 < N && grid[r][c+1] == 1) {
                    grid[r][c+1] = 2;
                    count--;
                    que.push({r, c+1});
                }
            }
        }
        
        // 如果还有新鲜橘子剩余，返回-1；否则返回所需时间
        return count > 0 ? -1 : minutes;
    }
};
```

### [429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

#### 方法：BFS，一个队列

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node *root) {
        if (root == nullptr) return {};  // 空树返回空数组
        
        vector<vector<int>> ans;          // 最终结果
        queue<Node*> q;                   // BFS队列
        q.push(root);                     // 根节点入队
        
        while (!q.empty()) {
            vector<int> vals;             // 当前层的节点值
            int levelSize = q.size();     // 当前层的节点数
            
            // 遍历当前层所有节点
            for (int i = 0; i < levelSize; i++) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);  // 收集节点值
                
                // 将当前节点的所有子节点入队
                for (auto child : node->children) {
                    q.push(child);
                }
            }
            
            ans.emplace_back(vals);  // 保存当前层的结果
        }
        
        return ans;
    }
};
```

### [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/)

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

#### 方法一：深度优先搜索











