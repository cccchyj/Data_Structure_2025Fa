
# 链表

## 反转链表

### [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

#### 方法一：迭代

![[Pasted image 20251229195254.png]]
![[Pasted image 20251229195301.png]]

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```
#### 方法二：递归

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```

### [92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

#### 方法：穿针引线

![[Pasted image 20251229195546.png]]
```cpp
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // 注意：切断链接
        pre->next = nullptr;
        rightNode->next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};
```

### [61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/description/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

![[Pasted image 20251229200206.png]]

#### 方法一：闭合为环

首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(kmodn) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        // 特殊情况处理
        if (k == 0 || head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 步骤1：计算链表长度 n，并找到尾节点 iter
        int n = 1;                     // 链表长度（至少1个节点）
        ListNode* iter = head;         // 用于遍历的指针
        while (iter->next != nullptr) {
            iter = iter->next;
            n++;
        }
        // 此时 iter 指向原链表的尾节点
        
        // 步骤2：计算实际需要移动的步数
        int add = n - k % n;           // 新尾节点的位置
        if (add == n) {                // 如果移动 n 的整数倍，链表不变
            return head;
        }
        
        // 步骤3：将链表首尾相连形成环
        iter->next = head;             // 尾节点指向头节点
        
        // 步骤4：找到新的尾节点
        while (add--) {                // 移动 add 步
            iter = iter->next;         // iter 最终指向新尾节点
        }
        
        // 步骤5：断开环，返回新头节点
        ListNode* ret = iter->next;    // 新头节点 = 新尾节点的下一个
        iter->next = nullptr;          // 断开环
        
        return ret;
    }
};
```

#### 方法二：**数组索引计算法**

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        // 特殊情况处理
        if (k == 0 || head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 步骤1：用数组存储所有节点指针
        vector<ListNode*> nodes;
        ListNode* cur = head;
        while (cur != nullptr) {
            nodes.push_back(cur);  // 将节点指针存入数组
            cur = cur->next;
        }
        
        int len = nodes.size();    // 链表长度
        
        // 步骤2：处理k值（旋转len次等于不旋转）
        k %= len;
        if (k == 0) {
            return nodes[0];       // 旋转0次，返回原头节点
        }
        
        // 步骤3：重新连接链表
        // 原尾节点指向原头节点，形成环
        nodes[len - 1]->next = nodes[0];
        
        // 新尾节点（索引len-k-1）的下一个置空
        nodes[len - k - 1]->next = nullptr;
        
        // 步骤4：返回新头节点（索引len-k）
        return nodes[len - k];
    }
};
```

### [25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

![[Pasted image 20251229201721.png]]

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 虚拟头节点，简化边界条件处理
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        
        ListNode* pre = dummy;  // 上一组的尾节点
        ListNode* end = dummy;  // 当前组的尾节点
        
        while (end->next != nullptr) {
            // 步骤1：找到当前组的尾节点 end
            for (int i = 0; i < k && end != nullptr; i++) {
                end = end->next;
            }
            if (end == nullptr) break;  // 剩余节点不足k个，直接结束
            
            // 步骤2：记录关键节点
            ListNode* start = pre->next;  // 当前组的头节点
            ListNode* nextGroup = end->next;  // 下一组的头节点
            
            // 步骤3：断开当前组与后面的连接（便于反转）
            end->next = nullptr;
            
            // 步骤4：反转当前组
            pre->next = reverse(start);  // 上一组的尾节点指向反转后的新头
            
            // 步骤5：重新连接（当前组的原头节点变为尾节点，指向下一组）
            start->next = nextGroup;
            
            // 步骤6：更新pre和end为当前组的尾节点（即原头节点start）
            pre = start;
            end = pre;
        }
        
        ListNode* result = dummy->next;
        delete dummy;  // 释放虚拟头节点
        return result;
    }

private:
    // 反转链表函数（标准迭代法）
    ListNode* reverse(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        
        while (curr != nullptr) {
            ListNode* next = curr->next;  // 保存下一个节点
            curr->next = prev;            // 反转指针
            prev = curr;                  // prev前移
            curr = next;                  // curr前移
        }
        
        return prev;  // 返回新的头节点
    }
};
```

## 合并链表

### [21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

#### 递归解法

- **终止条件**：当两个链表都为空时，表示我们对链表已合并完成。
- **如何递归**：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向**其余结点的合并结果。（调用递归）**

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
            return l2;
        }
        if (l2 == NULL) {
            return l1;
        }
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
};
```

### [1669. 合并两个链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-in-between-linked-lists/description/)

给你两个链表 `list1` 和 `list2` ，它们包含的元素分别为 `n` 个和 `m` 个。
请你将 `list1` 中下标从 `a` 到 `b` 的全部节点都删除，并将`list2` 接在被删除节点的位置。

![[Pasted image 20251229202842.png]]

```cpp
class Solution {
public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {
        // 步骤1：找到 list1 中第 a-1 个节点（要删除部分的前一个节点）
        ListNode* preA = list1;
        for (int i = 0; i < a - 1; i++) {
            preA = preA->next;
        }
        
        // 步骤2：找到 list1 中第 b+1 个节点（要删除部分的后一个节点）
        ListNode* preB = preA;  // 从preA开始，减少遍历次数
        for (int i = 0; i < b - a + 2; i++) {
            preB = preB->next;
        }
        
        // 步骤3：连接 list1 的前半部分到 list2
        preA->next = list2;
        
        // 步骤4：找到 list2 的尾节点
        while (list2->next != nullptr) {
            list2 = list2->next;
        }
        
        // 步骤5：连接 list2 的尾节点到 list1 的后半部分
        list2->next = preB;
        
        return list1;
    }
};
```

### [23. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

#### 方法一：顺序合并

我们可以想到一种最朴素的方法：用一个变量 ans 来维护以及合并的链表，第 i 次循环把第 i 个链表和 ans 合并，答案保存到 ans 中。

#### 方法二：分治合并

![[Pasted image 20251229203426.png]]

```cpp
class Solution {
public:
    // 合并两个有序链表
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);  // 连接剩余部分
        return head.next;
    }

    // 分治合并：类似归并排序
    ListNode* merge(vector<ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];          // 只有一个链表
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;               // 中点
        // 递归合并左右两部分
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```


#### 方法三：使用优先队列合并

```cpp
class Solution {
public:
    // 自定义优先队列节点状态
    struct Status {
        int val;          // 节点值
        ListNode *ptr;    // 节点指针
        // 重载<运算符，构建最小堆
        bool operator < (const Status &rhs) const {
            return val > rhs.val;  // 注意：使用 > 实现最小堆
        }
    };

    priority_queue<Status> q;  // 最小堆

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 初始化：将每个链表的头节点加入堆
        for (auto node: lists) {
            if (node) q.push({node->val, node});
        }
        ListNode head, *tail = &head;  // 虚拟头节点
        while (!q.empty()) {
            auto f = q.top(); q.pop();    // 取出最小值
            tail->next = f.ptr; 
            tail = tail->next;
            // 将下一个节点加入堆
            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});
        }
        return head.next;
    }
};
```