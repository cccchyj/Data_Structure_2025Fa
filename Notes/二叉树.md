# 二叉树

## 二叉树遍历

### [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

#### 方法一：递归

```cpp
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res) { // wrapper
        if (!root) {
            return;
        }
        inorder(root->left, res);  // 左子树
        res.push_back(root->val);  // 根
        inorder(root->right, res); // 右子树
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```
#### 方法二：迭代

先一路向左把结点压栈； 左子树走完后，访问栈顶结点； 再转向右子树。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;      // 保存中序遍历结果
        stack<TreeNode*> stk; // 模拟递归调用栈
        while (root != nullptr || !stk.empty()) {
	        // 外层循环：还能继续往下走；还能回溯访问父结点
            while (root != nullptr) {
	            // 内层循环：一路向左（只压栈，不访问）
                stk.push(root);    // 当前结点入栈
                root = root->left; // 一直走到最左下角
            }
            root = stk.top();         // 左子树已经处理完
            stk.pop();
            res.push_back(root->val); // 访问当前结点（中序的“根”）
            root = root->right;       // 转向右子树
        }
        return res;
    }
};
```

#### 方法三：Morris 中序遍历

Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。

Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：

1. 如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 x=x.right。
2. 如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。
* 如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x=x.left。
* 如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将 predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x=x.right。
3. 重复上述操作，直至访问完整棵树。

其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode *predecessor = nullptr;

        while (root != nullptr) {
            if (root->left != nullptr) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.push_back(root->val);
                    predecessor->right = nullptr;
                    root = root->right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.push_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```

### [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

#### 方法一：递归

```cpp
class Solution {
public:
    void preorder(TreeNode *root, vector<int> &res) {
        if (root == nullptr) {
            return;
        }
        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }

    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        preorder(root, res);
        return res;
    }
};
```

#### 方法二：迭代

一边访问结点，一边把结点压栈，然后不断往左走；  
左边走到底后，再通过栈回溯去处理右子树。

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (!stk.empty() || node != nullptr) {
	        // 外层循环控制：还能继续向下走；栈不空：还能回溯处理右子树
            while (node != nullptr) {
                res.emplace_back(node->val); // 访问当前结点
                stk.emplace(node);           // 当前结点入栈（为了以后回溯找右子树）
                node = node->left;           // 继续往左走
            }
            node = stk.top();    // 左子树已经走到底，从栈中取出最近的祖先结点
            stk.pop();
            node = node->right;  // 转向右子树
        }
        return res;
    }
};
```

#### 方法三：Morris 遍历

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：
* 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
* 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。

### [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

#### 方法一：递归

```cpp
class Solution {
public:
    void postorder(TreeNode *root, vector<int> &res) {
        if (root == nullptr) {
            return;
        }
        postorder(root->left, res);
        postorder(root->right, res);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        postorder(root, res);
        return res;
    }
};
```
#### 方法二：迭代

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            if (root->right == nullptr || root->right == prev) {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            } else {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
};
```

#### 方法三：Morris 遍历

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，则遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；
* 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。
* 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

这样我们利用 Morris 遍历的方法，后序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。

### [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

> [BFS 的使用场景总结：层序遍历、最短路径问题）](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244853/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/)

#### DFS 遍历使用 **递归**：

DFS 遍历整棵树，时间复杂度 O(n)，空间复杂度 O(h)（递归栈深度）

```cpp
void dfs(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    dfs(root->left);
    dfs(root->right);
}
```

#### BFS 遍历使用**队列**数据结构：

时间复杂度 O(n)（访问全部节点），空间复杂度 O(width)（队列最大宽度）

```cpp
void bfs(TreeNode* root) {
    if (root == nullptr) return;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        if (node->left != nullptr) {
            q.push(node->left);
        }
        if (node->right != nullptr) {
            q.push(node->right);
        }
    }
}
```

乍一看来，层序遍历和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。

https://pic.leetcode-cn.com/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif
![[Pasted image 20251220223959.png]]

我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。

层序遍历：

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res; // 二维容器，按层保存
        if (root == nullptr) return res;

        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int n = q.size();  // 记录当前层的结点数量，此时队列中正好是同一层的所有结点
            vector<int> level; // 保存当前层的所有结点值

            for (int i = 0; i < n; i++) {
	            // 一次 while 只处理一层，新加入队列的结点（孩子）属于下一层
                TreeNode* node = q.front();
                q.pop();

                level.push_back(node->val);

                if (node->left != nullptr) {
                    q.push(node->left);
                }
                if (node->right != nullptr) {
                    q.push(node->right);
                }
            }
            res.push_back(level);
        }
        return res;
    }
};

```

## 树的深度和平衡性

### [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

#### 方法一：深度优先搜索

如果我们知道了左子树和右子树的最大深度 $l$ 和 $r$，那么该二叉树的最大深度即为
$$max(l,r)+1$$
而左子树和右子树的最大深度又可以以同样的方式进行计算。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

#### 方法二：广度优先搜索

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        queue<TreeNode*> Q;
        Q.push(root);
        int ans = 0;
        while (!Q.empty()) {   // 每次循环 = 处理一整层；队列不空说明还有层没遍历
            int sz = Q.size(); // 当前队列中的结点，正好是同一层的所有结点
            while (sz > 0) {
                TreeNode* node = Q.front(); Q.pop();  // 弹出当前层的一个结点
                if (node->left) Q.push(node->left);   // 把它的左右孩子（下一层）加入队列
                if (node->right) Q.push(node->right);
                sz -= 1;                              // 直到当前层处理完
                // 注意：新加入的结点不会影响 `sz`，因为 `sz` 已经固定。
            }
            ans += 1; // 已经完整遍历了一层
        } 
        return ans;
    }
};
```

### [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

#### 方法一：深度优先搜索

```cpp
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }
		// 必须单独处理叶子结点和空子树，否则 `min()` 会把 0 当作合法深度导致错误
        if (root->left == nullptr && root->right == nullptr) {
            return 1;
        }

        int min_depth = INT_MAX; // 用 `INT_MAX` 初始化，避免空子树干扰
        if (root->left != nullptr) {
            min_depth = min(minDepth(root->left), min_depth);
        }
        if (root->right != nullptr) {
            min_depth = min(minDepth(root->right), min_depth);
        }

        return min_depth + 1;
    }
};
```

#### 方法二：广度优先搜索

```cpp
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }

        queue<pair<TreeNode *, int> > que; // 队列中保存节点 + 当前深度
        que.emplace(root, 1);
        while (!que.empty()) {
            TreeNode *node = que.front().first;
            int depth = que.front().second;
            que.pop();
            if (node->left == nullptr && node->right == nullptr) {
                return depth;
            } // 遇到第一个叶子结点立即返回深度
            if (node->left != nullptr) {
                que.emplace(node->left, depth + 1);
            } // 左右孩子入队，深度 +1
            if (node->right != nullptr) {
                que.emplace(node->right, depth + 1);
            }
        }

        return 0;
    }
};
```

### [110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

#### 方法一：自顶向下的递归

类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。
```cpp
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        } else {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) {
            return true;
        } else {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};
```
#### 方法二：自底向上的递归

类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```cpp
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int leftHeight = height(root->left);
        int rightHeight = height(root->right);
        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1) {
            return -1;
        } else {
            return max(leftHeight, rightHeight) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        return height(root) >= 0;
    }
};
```

### [543. 二叉树的直径 - 力扣（LeetCode）](https://leetcode.cn/problems/diameter-of-binary-tree/description/)

#### 方法：深度优先搜索

记节点 `node` 为起点的路径经过节点数的最大值为 $d_{node}$​ ，那么二叉树的直径就是所有节点 $d_{node}$​ 的最大值减一。

定义一个递归函数 `depth(node)` 计算 $d_{node}$  ，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 $L$ 和 $R$ ，则该节点为根的子树的深度即为 $\max(L,R)+1$，该节点的 $d_{node}$ 值为 $L+R+1$。

递归搜索每个节点并设一个全局变量 `ans` 记录 $d_{node}$  的最大值，最后返回 `ans-1` 即为树的直径。​
```cpp
class Solution {
    int ans;
    int depth(TreeNode* rt){
        if (rt == NULL) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(rt->left); // 左儿子为根的子树的深度
        int R = depth(rt->right); // 右儿子为根的子树的深度
        ans = max(ans, L + R + 1); // 计算d_node即L+R+1 并更新ans
        return max(L, R) + 1; // 返回该节点为根的子树的深度
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
};
```

## 树的重建

### [105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)
#### 方法一：递归

只要我们在中序遍历中**定位**到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。

```cpp
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```
#### 方法二：迭代？？？

用一个栈 stack 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 index 指向中序遍历的某个位置，初始值为 0。index 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的。

栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，**那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的**。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (!preorder.size()) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]);
        stack<TreeNode*> stk;
        stk.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.size(); ++i) {
            int preorderVal = preorder[i];
            TreeNode* node = stk.top();
            if (node->val != inorder[inorderIndex]) {
                node->left = new TreeNode(preorderVal);
                stk.push(node->left);
            }
            else {
                while (!stk.empty() && stk.top()->val == inorder[inorderIndex]) {
                    node = stk.top();
                    stk.pop();
                    ++inorderIndex;
                }
                node->right = new TreeNode(preorderVal);
                stk.push(node->right);
            }
        }
        return root;
    }
};
```

### [106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

#### 方法一：递归

后序遍历的数组最后一个元素代表的即为根节点。知道这个性质后，我们可以利用已知的根节点信息在中序遍历的数组中找到根节点所在的下标，然后根据其将中序遍历的数组分成左右两部分，左边部分即左子树，右边部分为右子树，针对每个部分可以用同样的方法继续递归下去构造。

- 为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（元素，下标）键值对的哈希表。

- 定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，递归入口为helper(0, n - 1) ：

	- 如果 in_left > in_right，说明子树为空，返回空节点。	
	- 选择后序遍历的最后一个节点作为根节点。	
	- 利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。	
	- 根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。注意这里有需要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。	
	- 返回根节点 root。

```cpp
class Solution {
    int post_idx;
    unordered_map<int, int> idx_map;
public:
    TreeNode* helper(int in_left, int in_right, vector<int>& inorder, vector<int>& postorder){
        // 如果这里没有节点构造二叉树了，就结束
        if (in_left > in_right) {
            return nullptr;
        }

        // 选择 post_idx 位置的元素作为当前子树根节点
        int root_val = postorder[post_idx];
        TreeNode* root = new TreeNode(root_val);

        // 根据 root 所在位置分成左右两棵子树
        int index = idx_map[root_val];

        // 下标减一
        post_idx--;
        // 构造右子树
        root->right = helper(index + 1, in_right, inorder, postorder);
        // 构造左子树
        root->left = helper(in_left, index - 1, inorder, postorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        // 从后序遍历的最后一个元素开始
        post_idx = (int)postorder.size() - 1;

        // 建立（元素，下标）键值对的哈希表
        int idx = 0;
        for (auto& val : inorder) {
            idx_map[val] = idx++;
        }
        return helper(0, (int)inorder.size() - 1, inorder, postorder);
    }
};
```
#### 方法二：迭代（略）

### [889. 根据前序和后序遍历构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/)

#### 方法：分治

令 n 为二叉树的节点数目，那么根据前序遍历与后序遍历的定义，preorder[0] 与 postorder[n−1] 都对应二叉树的根节点。获取根节点后，我们需要划分根节点的左子树与右子树，考虑两种情况：

- 原二叉树的根节点的左子树不为空，那么 preorder[1] 对应左子树的根节点；
- 原二叉树的根节点的左子树为空，那么 preorder[1] 对应右子树的根节点。

对于以上两种情况，我们无法区分 preorder[1] 到底是哪种情况。但是对于第二种情况，将原二叉树的右子树移到左子树后得到的二叉树的前序遍历数组与后序遍历数组与原二叉树相同，所以我们只需要考虑第一种情况。因为二叉树的值互不相同，我们可以在 postorder 中找到 postorder[k]=preorder[1]，那么左子树的节点数目为 k+1。

```cpp
class Solution {
public:
    TreeNode *constructFromPrePost(vector<int> &preorder, vector<int> &postorder) {
        int n = preorder.size();
        unordered_map<int, int> postMap; // 快速定位结点在后序中的位置
        for (int i = 0; i < n; i++) {
            postMap[postorder[i]] = i;
        }
        function<TreeNode *(int, int, int, int)> dfs = [&](int preLeft, int preRight, int postLeft, int postRight) -> TreeNode * {
            if (preLeft > preRight) { // 递归终止条件：子树为空
                return nullptr;
            }
            int leftCount = 0;
            if (preLeft < preRight) {
                leftCount = postMap[preorder[preLeft + 1]] - postLeft + 1; // 确定左子树的规模
            }
            return new TreeNode(preorder[preLeft], // 前序遍历的第一个元素一定是当前子树的根结点
                dfs(preLeft + 1, preLeft + leftCount, postLeft, postLeft + leftCount - 1),
                dfs(preLeft + leftCount + 1, preRight, postLeft + leftCount, postRight - 1));
        };
        return dfs(0, n - 1, 0, n - 1);
    }
};
```

### [297. 二叉树的序列化与反序列化 - 力扣（LeetCode）](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/)

#### 方法一：深度优先搜索

可以先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。那么我们如何反序列化呢？首先我们需要根据, 把原先的序列分割开来得到先序遍历的元素列表，然后从左向右遍历这个序列：

- 如果当前的元素为 None，则当前为空树
- 否则先解析这棵树的左子树，再解析它的右子树

```cpp
class Codec {
public:
    void rserialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += "None,";
        } else {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }

    string serialize(TreeNode* root) {
        string ret;
        rserialize(root, ret);
        return ret;
    }

    TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "None") {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }

        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }

    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        if (!str.empty()) {
            dataArray.push_back(str);
            str.clear();
        }
        return rdeserialize(dataArray);
    }
};
```

#### 方法二：括号表示编码 + 递归下降解码（略）

## 路径求解

### [112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/description/)

#### 方法一：广度优先搜索

使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和。

```cpp
class Solution {
public:
    // 判断是否存在一条从根结点到叶子结点的路径，使得路径上结点值之和等于 sum
    bool hasPathSum(TreeNode *root, int sum) {
        // 空树不可能存在路径
        if (root == nullptr) {
            return false;
        }

        // 队列1：存放当前遍历到的结点（用于层序遍历）
        queue<TreeNode *> que_node;
        // 队列2：存放从根到该结点的路径和
        queue<int> que_val;

        // 初始化：从根结点开始
        que_node.push(root);
        que_val.push(root->val);

        // 广度优先搜索（BFS）
        while (!que_node.empty()) {
            // 取出队首结点及其对应的路径和
            TreeNode *now = que_node.front();
            int temp = que_val.front();
            que_node.pop();
            que_val.pop();

            // 若当前结点是叶子结点，检查路径和是否等于 sum
            if (now->left == nullptr && now->right == nullptr) {
                if (temp == sum) {
                    return true;   // 找到满足条件的路径
                }
                continue;          // 继续检查其他路径
            }

            // 若存在左孩子，将左孩子入队
            // 路径和 = 当前路径和 + 左孩子的值
            if (now->left != nullptr) {
                que_node.push(now->left);
                que_val.push(now->left->val + temp);
            }

            // 若存在右孩子，将右孩子入队
            // 路径和 = 当前路径和 + 右孩子的值
            if (now->right != nullptr) {
                que_node.push(now->right);
                que_val.push(now->right->val + temp);
            }
        }

        // 所有路径检查完仍未找到满足条件的
        return false;
    }
};
```
#### ⭐方法二：递归

假定从根节点到当前节点的值之和为 `val`，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 `sum - val`。

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        // 基本情况1：空树，不存在任何路径
        if (root == nullptr) {
            return false;
        }
        
        // 基本情况2：当前节点是叶子节点（左右子树都为空）
        // 检查剩余 sum 是否等于叶子节点的值
        if (root->left == nullptr && root->right == nullptr) {
            return sum == root->val;
        }
        
        // 递归情况：当前节点不是叶子
        // 分别在左右子树中寻找路径，目标值减去当前节点的值
        return hasPathSum(root->left, sum - root->val) ||
               hasPathSum(root->right, sum - root->val);
    }
};
```

### [113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/description/)

要求：找到**所有**满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。

#### ⭐方法一：深度优先搜索

```cpp
class Solution {
public:
    vector<vector<int>> ret;  // 存储所有符合条件的路径
    vector<int> path;         // 当前递归路径

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        // 进入节点：加入路径并更新剩余和
        path.emplace_back(root->val);
        targetSum -= root->val;
        
        // 叶子节点且剩余和为0：找到一条有效路径
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        
        // 递归遍历左右子树
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        
        // 回溯：离开节点前从路径中移除当前节点
        path.pop_back();
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};
```

#### 方法二：广度优先搜索

为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。

```cpp
class Solution {
public:
    vector<vector<int>> ret;                     // 存储所有符合条件的路径
    unordered_map<TreeNode*, TreeNode*> parent;  // 记录每个节点的父节点，用于回溯路径

    // 根据哈希表 parent 从叶子节点回溯到根节点，重建路径
    void getPath(TreeNode* node) {
        vector<int> tmp;
        while (node != nullptr) {
            tmp.emplace_back(node->val);
            node = parent[node];  // 回溯到父节点
        }
        reverse(tmp.begin(), tmp.end());  // 回溯得到的是逆序，需要反转
        ret.emplace_back(tmp);
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return ret;

        // BFS队列：分别存储节点和从根到该节点的路径和
        queue<TreeNode*> que_node;  // 节点队列
        queue<int> que_sum;         // 路径和队列
        que_node.emplace(root);
        que_sum.emplace(0);         // 初始路径和为0

        while (!que_node.empty()) {
            TreeNode* node = que_node.front(); que_node.pop();
            int rec = que_sum.front() + node->val;  // 计算到当前节点的路径和
            que_sum.pop();

            // 叶子节点检查：如果路径和等于目标值，记录路径
            if (node->left == nullptr && node->right == nullptr) {
                if (rec == targetSum) {
                    getPath(node);
                }
            } 
            // 非叶子节点：将子节点加入队列，并记录父子关系
            else {
                if (node->left != nullptr) {
                    parent[node->left] = node;       // 记录左孩子的父节点
                    que_node.emplace(node->left);
                    que_sum.emplace(rec);            // 传递当前路径和
                }
                if (node->right != nullptr) {
                    parent[node->right] = node;      // 记录右孩子的父节点
                    que_node.emplace(node->right);
                    que_sum.emplace(rec);
                }
            }
        }
        return ret;
    }
};
```

### [437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/description/)

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

#### 方法一：深度优先搜索

穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。

定义 $rootSum(p,val)$ 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。
节点 p 的 $rootSum(p,targetSum)$ 即等于 $rootSum(p_l ,targetSum−val)$ 与 $rootSum(p_r ,targetSum−val)$ 之和，同时我们还需要判断一下当前节点 p 的值是否刚好等于 $targetSum$。
```cpp
class Solution {
public:
    int rootSum(TreeNode* root, long long targetSum) {
        if (!root) {
            return 0;
        }

        int ret = 0;
        if (root->val == targetSum) {
            ret++;
        } 

        ret += rootSum(root->left, targetSum - root->val);
        ret += rootSum(root->right, targetSum - root->val);
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root) {
            return 0;
        }
        
        int ret = rootSum(root, targetSum);
        ret += pathSum(root->left, targetSum);
        ret += pathSum(root->right, targetSum);
        return ret;
    }
};
```
#### 方法二: 前缀和

我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去 targetSum。

```cpp
class Solution {
public:
    unordered_map<long long, int> prefix;  // 前缀和 -> 出现次数
    
    int dfs(TreeNode *root, long long curr, int targetSum) {
        if (!root) return 0;
        
        int ret = 0;
        curr += root->val;  // 当前路径和
        
        // 关键：检查是否存在前缀和 prefix[curr - targetSum]
        // 如果存在，说明从那个节点到当前节点的路径和 = targetSum
        if (prefix.count(curr - targetSum)) {
            ret = prefix[curr - targetSum];
        }
        
        // 将当前前缀和加入哈希表
        prefix[curr]++;
        // 递归处理左右子树
        ret += dfs(root->left, curr, targetSum);
        ret += dfs(root->right, curr, targetSum);
        // 回溯：离开当前节点时，移除当前前缀和
        prefix[curr]--;
        
        return ret;
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        prefix[0] = 1;  // 初始前缀和0出现1次（空路径）
        return dfs(root, 0, targetSum);
    }
};
```

### [124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

#### 方法：递归

```cpp
class Solution {
private:
    int maxSum = INT_MIN;

public:
    int maxGain(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node->val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;
    }
};
```

### [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/description/)

#### 方法一：深度优先搜索

- 如果当前节点**不是叶子节点**，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
- 如果当前节点**是叶子节点**，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。
```cpp
class Solution {
public:
    void construct_paths(TreeNode* root, string path, vector<string>& paths) {
        if (root != nullptr) {
            path += to_string(root->val);
            if (root->left == nullptr && root->right == nullptr) {  // 当前节点是叶子节点
                paths.push_back(path);                              // 把路径加入到答案中
            } else {
                path += "->";  // 当前节点不是叶子节点，继续递归遍历
                construct_paths(root->left, path, paths);
                construct_paths(root->right, path, paths);
            }
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> paths;
        construct_paths(root, "", paths);
        return paths;
    }
};
```
#### 方法二：广度优先搜索

我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它**是叶子节点**，则将它对应的路径加入到答案中。如果它**不是叶子节点**，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> paths;
        if (root == nullptr) {
            return paths;
        }
        queue<TreeNode*> node_queue;
        queue<string> path_queue;

        node_queue.push(root);
        path_queue.push(to_string(root->val));

        while (!node_queue.empty()) {
            TreeNode* node = node_queue.front(); 
            string path = path_queue.front();
            node_queue.pop();
            path_queue.pop();

            if (node->left == nullptr && node->right == nullptr) {
                paths.push_back(path);
            } else {
                if (node->left != nullptr) {
                    node_queue.push(node->left);
                    path_queue.push(path + "->" + to_string(node->left->val));
                }

                if (node->right != nullptr) {
                    node_queue.push(node->right);
                    path_queue.push(path + "->" + to_string(node->right->val));
                }
            }
        }
        return paths;
    }
};
```

### [129. 求根节点到叶节点数字之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return helper(root, 0);
    }

private:
    // DFS辅助函数：root: 当前节点；sum: 从根节点到当前节点父节点的路径和
    int helper(TreeNode* root, int sum) {
        // 空节点，返回0
        if (root == nullptr) {
            return 0;
        }
        
        // 计算从根到当前节点的路径和
        // 将之前的和乘以10（十进制左移一位）再加上当前节点的值
        int currentSum = sum * 10 + root->val;
        
        // 如果是叶子节点，返回当前路径和
        if (root->left == nullptr && root->right == nullptr) {
            return currentSum;
        }
        
        // 非叶子节点：递归计算左右子树的路径和，并相加
        return helper(root->left, currentSum) + helper(root->right, currentSum);
    }
};
```

## 二叉搜索树

### [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/)

#### 方法一: 递归

**如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；** 
**若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。**

这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是**开区间**）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。

那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。

函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。
```cpp
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```
#### 方法二：中序遍历

二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) {
                return false;
            }
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }
};
```

### [700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

#### 方法一：递归

```cpp
class Solution {
public:
    TreeNode *searchBST(TreeNode *root, int val) {
        if (root == nullptr) {
            return nullptr;
        }
        if (val == root->val) {
            return root;
        }
        return searchBST(val < root->val ? root->left : root->right, val);
    }
};
```
#### 方法二：迭代

```cpp
class Solution {
public:
    TreeNode *searchBST(TreeNode *root, int val) {
        while (root) {
            if (val == root->val) {
                return root;
            }
            root = val < root->val ? root->left : root->right;
        }
        return nullptr;
    }
};
```

### [450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

#### 方法一：递归

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) {
            return nullptr;  // 空树或未找到key
        }
        
        // 1. 查找要删除的节点
        if (root->val > key) {
            root->left = deleteNode(root->left, key);  // 在左子树中删除
            return root;
        }
        if (root->val < key) {
            root->right = deleteNode(root->right, key); // 在右子树中删除
            return root;
        }
        
        // 2. 找到要删除的节点 root->val == key
        if (!root->left && !root->right) {
            // 情况1：叶子节点，直接删除
            return nullptr;
        }
        if (!root->right) {
            // 情况2：只有左子树，用左子树替代
            return root->left;
        }
        if (!root->left) {
            // 情况3：只有右子树，用右子树替代
            return root->right;
        }
        
        // 情况4：左右子树都存在
        // 找到右子树的最小节点（中序后继）
        TreeNode *successor = root->right;
        while (successor->left) {
            successor = successor->left;
        }
        
        // 递归删除 successor（它可能有右子树）
        root->right = deleteNode(root->right, successor->val);
        
        // 用 successor 替换 root
        successor->right = root->right;  // 注意：要先更新右子树
        successor->left = root->left;
        
        return successor;  // 返回新的根节点
    }
};
```

#### 方法二：迭代

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode *cur = root, *curParent = nullptr;
        
        // 1. 查找要删除的节点 cur，并记录其父节点 curParent
        while (cur && cur->val != key) {
            curParent = cur;
            if (cur->val > key) {
                cur = cur->left;
            } else {
                cur = cur->right;
            }
        }
        if (!cur) {
            return root;  // 没找到 key，直接返回原树
        }
        
        // 2. 删除节点 cur（根据子节点数量分4种情况）
        if (!cur->left && !cur->right) {
            // 情况1：叶子节点，直接删除
            cur = nullptr;
        } else if (!cur->right) {
            // 情况2：只有左子树，用左子树替代
            cur = cur->left;
        } else if (!cur->left) {
            // 情况3：只有右子树，用右子树替代
            cur = cur->right;
        } else {
            // 情况4：左右子树都存在
            // 找到右子树的最小节点（中序后继）及其父节点
            TreeNode *successor = cur->right, *successorParent = cur;
            while (successor->left) {
                successorParent = successor;
                successor = successor->left;
            }
            
            // 将 successor 从其原位置删除
            if (successorParent->val == cur->val) {
                // successor 就是 cur 的右子节点（没有左子树）
                successorParent->right = successor->right;
            } else {
                // successor 在其父节点的左子树中
                successorParent->left = successor->right;
            }
            
            // 用 successor 替换 cur
            successor->right = cur->right;
            successor->left = cur->left;
            cur = successor;
        }
        
        // 3. 更新父节点指针
        if (!curParent) {
            // 删除的是根节点
            return cur;
        } else {
            // 更新父节点的 left 或 right 指针
            if (curParent->left && curParent->left->val == key) {
                curParent->left = cur;
            } else {
                curParent->right = cur;
            }
            return root;
        }
    }
};
```

### [230. 二叉搜索树中第 K 小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)

#### 方法一：中序遍历

使用迭代方法，这样可以在找到答案后停止，不需要遍历整棵树。
```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode *> stack;
        while (root != nullptr || stack.size() > 0) {
            while (root != nullptr) {
                stack.push(root);
                root = root->left;
            }
            root = stack.top();
            stack.pop();
            --k;
            if (k == 0) {
                break;
            }
            root = root->right;
        }
        return root->val;
    }
};
```




