// generated by doubao
#include <iostream>
#include <vector>
#include <string>
//#include <algorithm>
#include "sort.h"

using std::cout; using std::endl; using std::vector;

// 打印向量内容的辅助函数
template <typename T>
void printVector(const vector<T>& vec, const std::string& label) {
    cout << label << ": ";
    for (size_t i = 0; i < vec.size(); ++i) {
        if (i > 0) cout << ", ";
        cout << vec[i];
    }
    cout << endl;
}

// 测试单个排序算法的通用函数
template <typename T, typename SortFunc>
void testSortAlgorithm(const vector<T>& original, SortFunc sortFunc, const std::string& algorithmName) {
    vector<T> sorted = original;
    sortFunc(sorted);  // 执行排序
    
    printVector(original, "  排序前");
    printVector(sorted, "  " + algorithmName + "后");
    cout << "----------------------------------------" << endl;
}

int main() {
    // 测试数据集 - 整数
    vector<vector<int>> intTestCases = {
        {},                              // 空向量
        {5},                             // 单元素
        {1, 2, 3, 4, 5},                 // 已排序
        {5, 4, 3, 2, 1},                 // 逆序
        {3, 1, 4, 1, 5, 9, 2, 6},        // 随机顺序
        {2, 2, 2, 2},                    // 重复元素
        {10, -3, 5, 0, 8, -1, 12}        // 包含负数
    };

    // 测试数据集 - 浮点数
    vector<vector<double>> doubleTestCases = {
        {3.14, 1.59, 2.65, 3.58, 9.79},
        {10.0, -5.5, 3.14, 0.0, 7.2}
    };

    // 测试数据集 - 字符串
    vector<vector<std::string>> stringTestCases = {
        {"apple", "banana", "cherry", "date"},
        {"date", "cherry", "banana", "apple"},
        {"zebra", "apple", "mango", "banana"}
    };

    // 测试插入排序
    cout << "=== 插入排序测试 ===" << endl;
    for (const auto& testCase : intTestCases) {
        testSortAlgorithm(testCase, 
                         [](vector<int>& v) { insertionSort(v); }, 
                         "插入排序");
    }

    // 测试归并排序
    cout << "\n=== 归并排序测试 ===" << endl;
    for (const auto& testCase : intTestCases) {
        testSortAlgorithm(testCase, 
                         [](vector<int>& v) { 
                             if (!v.empty()) mergeSort(v, 0, v.size() - 1); 
                         }, 
                         "归并排序");
    }

    // 测试快速排序
    cout << "\n=== 快速排序测试 ===" << endl;
    for (const auto& testCase : intTestCases) {
        testSortAlgorithm(testCase, 
                         [](vector<int>& v) { 
                             if (!v.empty()) quickSort(v, 0, v.size() - 1); 
                         }, 
                         "快速排序");
    }

    // 浮点数测试
    cout << "\n=== 浮点数排序测试 ===" << endl;
    for (const auto& testCase : doubleTestCases) {
        testSortAlgorithm(testCase, 
                         [](vector<double>& v) { insertionSort(v); }, 
                         "插入排序");
        
        testSortAlgorithm(testCase, 
                         [](vector<double>& v) { 
                             if (!v.empty()) mergeSort(v, 0, v.size() - 1); 
                         }, 
                         "归并排序");
        
        testSortAlgorithm(testCase, 
                         [](vector<double>& v) { 
                             if (!v.empty()) quickSort(v, 0, v.size() - 1); 
                         }, 
                         "快速排序");
    }

    // 字符串测试
    cout << "\n=== 字符串排序测试 ===" << endl;
    for (const auto& testCase : stringTestCases) {
        testSortAlgorithm(testCase, 
                         [](vector<std::string>& v) { insertionSort(v); }, 
                         "插入排序");
        
        testSortAlgorithm(testCase, 
                         [](vector<std::string>& v) { 
                             if (!v.empty()) mergeSort(v, 0, v.size() - 1); 
                         }, 
                         "归并排序");
        
        testSortAlgorithm(testCase, 
                         [](vector<std::string>& v) { 
                             if (!v.empty()) quickSort(v, 0, v.size() - 1); 
                         }, 
                         "快速排序");
    }

    return 0;
}